* Test BLOWFISH function!
DIM T(9,3), DTA(8)
*
CRT 'Test ECB mode..'
*   key                 plain text          cipher text (ECB)
*   .................   .................   .................
T(1,1)="0000000000000000";  T(1,2)="0000000000000000";  T(1,3)="4EF997456198DD78"
T(2,1)="FFFFFFFFFFFFFFFF";  T(2,2)="FFFFFFFFFFFFFFFF";  T(2,3)="51866FD5B85ECB8A"
T(3,1)="3000000000000000";  T(3,2)="1000000000000001";  T(3,3)="7D856F9A613063F2"
T(4,1)="1111111111111111";  T(4,2)="1111111111111111";  T(4,3)="2466DD878B963C9D"
T(5,1)="0123456789ABCDEF";  T(5,2)="1111111111111111";  T(5,3)="61F9C3802281B096"
T(6,1)="1111111111111111";  T(6,2)="0123456789ABCDEF";  T(6,3)="7D0CC630AFDA1EC7"
T(7,1)="FEDCBA9876543210";  T(7,2)="0123456789ABCDEF";  T(7,3)="0ACEAB0FC6A0A28D"
T(8,1)="7CA110454A1A6E57";  T(8,2)="01A1D6D039776742";  T(8,3)="59C68245EB05282B"
T(9,1)="0131D9619DC1376E";  T(9,2)="5CD54CA83DEF57DA";  T(9,3)="B1B8CC0B250F09A0"
GOSUB 1000
*
T(1,1)="F0E1D2C3B4";  T(1,2)="FEDCBA9876543210";  T(1,3)="B39E44481BDB1E6E"
T(2,1)="F0E1D2C3B4A5";  T(2,2)="FEDCBA9876543210";  T(2,3)="9457AA83B1928C0D"
T(3,1)="F0E1D2C3B4A59687";  T(3,2)="FEDCBA9876543210";  T(3,3)="E87A244E2CC85E82"
T(4,1)="F0E1D2C3B4A5968778";  T(4,2)="FEDCBA9876543210";  T(4,3)="15750E7A4F4EC577"
T(5,1)="F0E1D2C3B4A5968778695A4B";  T(5,2)="FEDCBA9876543210";  T(5,3)="9409DA87A90F6BF2"
T(6,1)="F0E1D2C3B4A5968778695A4B3C2D1E0F00112233";  T(6,2)="FEDCBA9876543210";  T(6,3)="10851C0E3858DA9F"
T(7,1)="F0E1D2C3B4A5968778695A4B3C2D1E0F0011223344";  T(7,2)="FEDCBA9876543210";  T(7,3)="E6F51ED79B9DB21F"
T(8,1)="F0E1D2C3B4A5968778695A4B3C2D1E0F00112233445566";  T(8,2)="FEDCBA9876543210";  T(8,3)="80C7D7D45A5479AD"
T(9,1)="F0E1D2C3B4A5968778695A4B3C2D1E0F0011223344556677";  T(9,2)="FEDCBA9876543210";  T(9,3)="05044B62FA52D080"
GOSUB 1000
*
* test CBC mode!
*
CRT 'Test CBC mode..'
VAL = "0123456789ABCDEFF0E1D2C3B4A59687"
GOSUB 2000
CALL BLOWFISH(0,VAL,MAT DTA,ERR)
IF ERR THEN CRT 'KEY GEN ERR=':ERR ; STOP
*
* Init IV
VAL = "FEDCBA9876543210"
GOSUB 2000
FOR I = 1 TO 8
  DTA(I) = SEQ(VAL[I,1])
NEXT I
*
VAL = "37363534333231204E6F77206973207468652074696D6520666F722000"
GOSUB 2000
PT = VAL    ;* Save 'plain text'
CALL BLOWFISH(3,VAL,MAT DTA,ERR)
IF ERR THEN CRT 'ECB ENCRYPT ERR=':ERR ; STOP
SVAL = VAL  ;* Save encrypted text
GOSUB 3000
RES = "6B77B4D63006DEE605B156E27403979358DEB9E7154616D959F1652BD5FF92CC"
IF RES = VAL THEN
   * Init IV again
   VAL = "FEDCBA9876543210"
   GOSUB 2000
   FOR I = 1 TO 8
      DTA(I) = SEQ(VAL[I,1])
   NEXT I
   CALL BLOWFISH(4,SVAL,MAT DTA,ERR)
   IF ERR THEN CRT 'ECB DECRYPT ERR=':ERR ; STOP
   * Is decrypted 'encryption text' same as saved 'plain text'?
   IF SVAL[1, LEN(PT)] # PT THEN
      CRT 'CBC DECRYPT ERROR!'
   END
END ELSE
   CRT 'CBC DECRYPT ERROR!'
END
*
* Test check too short keys!
CALL BLOWFISH(0,'1234',MAT DTA,ERR)
IF NOT(ERR = 1) THEN
   CRT 'Check for small user keys failed!'
END
*
CRT 'All done!'
STOP
*
1000*
*
FOR ZZ = 1 TO 9
   VAL = T(ZZ,1) ; GOSUB 2000 ; KEY = VAL
   VAL = T(ZZ,2) ; GOSUB 2000 ; DVL = VAL
   VAL = T(ZZ,3) ; GOSUB 2000 ; RES = VAL
   * MAKE KEY
   SVAL = KEY
   CALL BLOWFISH(0,SVAL,MAT DTA,ERR)
   IF ERR THEN CRT 'KEY GEN ERR=':ERR ; STOP
   *
   FOR I = 1 TO 8
      DTA(I) = SEQ(DVL[I,1])
   NEXT I
   *
   * Encrypt plaintext ECB
   CALL BLOWFISH(1,'',MAT DTA,ERR)
   IF ERR THEN CRT 'ECB ENCRYPT ERR=':ERR ; STOP
   *
   * Get cipher text output!
   ACTUAL = ''
   FOR I = 1 TO 8
      ACTUAL = ACTUAL:CHAR(DTA(I))
   NEXT I
   IF ACTUAL = RES THEN
      *
      * Decrypt plaintext ECB
      CALL BLOWFISH(2,'',MAT DTA,ERR)
      IF ERR THEN CRT 'ECB DECRYPT ERR=':ERR ; STOP
      *
      * Get cipher text output!
      ACTUAL = ''
      FOR I = 1 TO 8
         ACTUAL = ACTUAL:CHAR(DTA(I))
      NEXT I
      IF ACTUAL # DVL THEN
         CRT 'ECB - DECRYPT FAILED!'
      END
   END ELSE
      CRT 'ECB - ENCRYPT FAILED!'
   END
NEXT ZZ
RETURN
*
2000* Return emulation of ICONV(VAL,"MX") in 'VAL' given 'VAL' as input
*
VAL3 = ""
VAL1 = LEN(VAL)
IF VAL1 > 1 THEN
   IF MOD(VAL1, 2) # 0 THEN
      VAL = "0":VAL
      VAL1 = VAL1 + 1
   END
   FOR VAL2 = 1 TO VAL1 STEP 2
      VAL3 = VAL3:CHAR(OCONV(VAL[VAL2, 2], "MCXD"))
   NEXT VAL2
   VAL = VAL3
END
RETURN
*
3000* Return emulation of OCONV(VAL,"MX") in 'VAL' given 'VAL' as input
*
VAL3 = ""
VAL1 = LEN(VAL)
FOR VAL2 = 1 TO VAL1
   VAL3 = VAL3:OCONV(SEQ(VAL[VAL2, 1]), 'MCDX') "R%2"
NEXT VAL2
VAL = VAL3
RETURN
*
END
